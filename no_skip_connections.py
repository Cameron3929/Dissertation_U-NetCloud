# -*- coding: utf-8 -*-
"""No Skip Connections

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BCJXHogEK_1yND9VpfuKV24vqZQ8JbmJ
"""

# === Script B: No Skip Connections (Skip=OFF, Double-Conv=ON) ===

# 1Ô∏è‚É£ Mount & Imports
from google.colab import drive
drive.mount('/content/drive', force_remount=True)

import os, glob
import numpy as np
from PIL import Image
from tqdm import tqdm
import torch, torch.nn as nn, torch.optim as optim
from torch.utils.data import Dataset, DataLoader, Subset

# 2Ô∏è‚É£ Hyperparams
BASE_PATH   = '/content/drive/MyDrive/95Clouds/38-Cloud_training'
MAX_SAMPLES = 1050
BATCH_SIZE  = 8
DEVICE      = torch.device('cuda' if torch.cuda.is_available() else 'cpu')

# 3Ô∏è‚É£ Metrics (same as above) ‚Ä¶
def dice(p,t,eps=1e-6):
    p=(p>0.5).float(); i=(p*t).sum()
    return (2*i+eps)/(p.sum()+t.sum()+eps)
def iou(p,t,eps=1e-6):
    p=(p>0.5).float(); i=(p*t).sum(); u=(p+t).clamp(0,1).sum()
    return (i+eps)/(u+eps)
def precision(p,t,eps=1e-6):
    p=(p>0.5).float(); tp=(p*t).sum(); fp=(p*(1-t)).sum()
    return (tp+eps)/(tp+fp+eps)
def recall(p,t,eps=1e-6):
    p=(p>0.5).float(); tp=(p*t).sum(); fn=((1-p)*t).sum()
    return (tp+eps)/(tp+fn+eps)
def pixel_acc(p,t):
    p=(p>0.5).float()
    return (p==t).float().sum()/torch.numel(t)

# 4Ô∏è‚É£ Dataset (same as above) ‚Ä¶
class CloudDataset(Dataset):
    def __init__(self, base_path):
        self.r = sorted(glob.glob(os.path.join(base_path,'train_red','*.TIF')))
        self.g = sorted(glob.glob(os.path.join(base_path,'train_green','*.TIF')))
        self.b = sorted(glob.glob(os.path.join(base_path,'train_blue','*.TIF')))
        self.gt= sorted(glob.glob(os.path.join(base_path,'train_gt','*.TIF')))
        assert len(self.r)==len(self.g)==len(self.b)==len(self.gt), "Mismatch"
    def __len__(self): return len(self.r)
    def __getitem__(self, idx):
        def load(p): return np.array(Image.open(p),dtype=np.float32)/255.0
        r,g,b,gt = load(self.r[idx]), load(self.g[idx]), load(self.b[idx]), load(self.gt[idx])
        x = np.stack([r,g,b],axis=0)
        return torch.tensor(x), torch.tensor(gt[None],dtype=torch.float32)

# 5Ô∏è‚É£ Model (No Skip)
class UNetNoSkip(nn.Module):
    def __init__(self):
        super().__init__()
        def C(in_ch,out_ch):
            return nn.Sequential(
                nn.Conv2d(in_ch, out_ch, 3, padding=1),
                nn.ReLU(inplace=True),
                nn.Conv2d(out_ch,out_ch,3,padding=1),
                nn.ReLU(inplace=True)
            )
        self.e1=C(3,64); self.e2=C(64,128)
        self.e3=C(128,256);self.e4=C(256,512)
        self.pool=nn.MaxPool2d(2)
        self.up  = lambda z: nn.functional.interpolate(z,scale_factor=2,mode='bilinear',align_corners=True)
        # remove_skips=True -> no concat dims
        self.d3=C(512,256)
        self.d2=C(256,128)
        self.d1=C(128,64)
        self.final=nn.Conv2d(64,1,1)

    def forward(self,x):
        e1=self.e1(x)
        e2=self.e2(self.pool(e1))
        e3=self.e3(self.pool(e2))
        e4=self.e4(self.pool(e3))
        d3=self.d3(self.up(e4))
        d2=self.d2(self.up(d3))
        d1=self.d1(self.up(d2))
        return torch.sigmoid(self.final(d1))

# 6Ô∏è‚É£ Prepare DataLoader
full_ds = CloudDataset(BASE_PATH)
sub_ds  = Subset(full_ds, list(range(min(MAX_SAMPLES,len(full_ds)))))
loader  = DataLoader(sub_ds, batch_size=BATCH_SIZE, shuffle=True)
print(f"‚ñ∂ Using {len(sub_ds)} samples")

# 7Ô∏è‚É£ Train 1 epoch
model   = UNetNoSkip().to(DEVICE)
opt     = optim.Adam(model.parameters(), lr=1e-3)
loss_fn = nn.BCELoss()

model.train()
for x,y in tqdm(loader, desc='Training NoSkip'):
    x,y = x.to(DEVICE), y.to(DEVICE)
    p   = model(x); loss=loss_fn(p,y)
    opt.zero_grad(); loss.backward(); opt.step()

# 8Ô∏è‚É£ Eval
model.eval()
sums = dict(dice=0,iou=0,prec=0,rec=0,acc=0)
with torch.no_grad():
    for x,y in tqdm(loader, desc='Evaluating NoSkip'):
        x,y = x.to(DEVICE), y.to(DEVICE)
        p   = model(x)
        for i in range(x.size(0)):
            sums['dice'] += dice(p[i:i+1], y[i:i+1]).item()
            sums['iou']  += iou(p[i:i+1], y[i:i+1]).item()
            sums['prec'] += precision(p[i:i+1],y[i:i+1]).item()
            sums['rec']  += recall(p[i:i+1],  y[i:i+1]).item()
            sums['acc']  += pixel_acc(p[i:i+1],y[i:i+1]).item()

N=len(sub_ds)
print("\nüìä No Skip Metrics:")
print(f" Dice:     {sums['dice']/N:.4f}")
print(f" IoU:      {sums['iou']/N:.4f}")
print(f" Precision:{sums['prec']/N:.4f}")
print(f" Recall:   {sums['rec']/N:.4f}")
print(f" Accuracy: {sums['acc']/N:.4f}")