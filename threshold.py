# -*- coding: utf-8 -*-
"""Threshold

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ahtPE-p8O4zzhi4qNZdeKlWV_7SoRVda
"""

# ─── Threshold Baseline on First 1 050 Training Patches ───

from google.colab import drive
drive.mount('/content/drive', force_remount=True)

import os, glob
import numpy as np
import cv2
from tqdm import tqdm

# 1️⃣ Point at your *training* folder, not the test scenes:
BASE = '/content/drive/MyDrive/95Clouds/38-Cloud_training'

# grab exactly 1 050 of each channel + ground‐truth
red_files   = sorted(glob.glob(os.path.join(BASE,'train_red','*.TIF')))[:1050]
green_files = sorted(glob.glob(os.path.join(BASE,'train_green','*.TIF')))[:1050]
blue_files  = sorted(glob.glob(os.path.join(BASE,'train_blue','*.TIF')))[:1050]
nir_files   = sorted(glob.glob(os.path.join(BASE,'train_nir','*.TIF')))[:1050]
gt_files    = sorted(glob.glob(os.path.join(BASE,'train_gt','*.TIF')))[:1050]

assert len(red_files)==len(green_files)==len(blue_files)==len(nir_files)==len(gt_files)==1050, \
       "Must pick exactly 1 050 patches"

# 2️⃣ Metric definitions
def dice(pred, gt, eps=1e-6):
    inter = np.sum(pred * gt)
    return (2*inter + eps) / (pred.sum() + gt.sum() + eps)

def iou(pred, gt, eps=1e-6):
    inter = np.sum(pred * gt)
    union = np.sum((pred + gt) > 0)
    return (inter + eps) / (union + eps)

def precision(pred, gt, eps=1e-6):
    tp = np.sum((pred==1) & (gt==1))
    fp = np.sum((pred==1) & (gt==0))
    return (tp + eps) / (tp + fp + eps)

def recall(pred, gt, eps=1e-6):
    tp = np.sum((pred==1) & (gt==1))
    fn = np.sum((pred==0) & (gt==1))
    return (tp + eps) / (tp + fn + eps)

def pixel_accuracy(pred, gt):
    return np.mean(pred == gt)

# 3️⃣ Brightness‐threshold
def brightness_threshold(r, g, b, thresh=0.5):
    # standard luminance
    lum = 0.2989*r + 0.5870*g + 0.1140*b
    return (lum > (thresh*255)).astype(np.uint8)

# 4️⃣ Run over 1 050 patches
dice_scores = []
iou_scores  = []
prec_scores = []
rec_scores  = []
acc_scores  = []

for r_path, g_path, b_path, n_path, gt_path in tqdm(
        zip(red_files, green_files, blue_files, nir_files, gt_files),
        total=1050, desc='Threshold eval'):
    # load grayscale
    r  = cv2.imread(r_path,   cv2.IMREAD_GRAYSCALE).astype(np.float32)
    g  = cv2.imread(g_path,   cv2.IMREAD_GRAYSCALE).astype(np.float32)
    b  = cv2.imread(b_path,   cv2.IMREAD_GRAYSCALE).astype(np.float32)
    gt = cv2.imread(gt_path,  cv2.IMREAD_GRAYSCALE)

    # binarize GT
    gt_bin = (gt > 127).astype(np.uint8)
    # predict via threshold on RGB only
    pred = brightness_threshold(r, g, b, thresh=0.5)

    dice_scores.append(    dice(pred, gt_bin))
    iou_scores.append(     iou(pred, gt_bin))
    prec_scores.append(precision(pred, gt_bin))
    rec_scores.append(    recall(pred, gt_bin))
    acc_scores.append(pixel_accuracy(pred, gt_bin))

# 5️⃣ Print results
print(f"\n✅ Threshold baseline on 1 050 training patches:")
print(f" Dice:      {np.mean(dice_scores):.4f}")
print(f" IoU:       {np.mean(iou_scores) :.4f}")
print(f" Precision: {np.mean(prec_scores):.4f}")
print(f" Recall:    {np.mean(rec_scores) :.4f}")
print(f" Accuracy:  {np.mean(acc_scores):.4f}")